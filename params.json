{"name":"Semantic logger","tagline":"Scalable, next generation logging for Ruby","body":"semantic_logger [![Build Status](https://secure.travis-ci.org/reidmorrison/semantic_logger.png?branch=master)](http://travis-ci.org/reidmorrison/semantic_logger)\r\n===============\r\n\r\nNext generation logging system for Ruby to support highly concurrent, high throughput, low latency systems\r\n\r\n* http://github.com/reidmorrison/semantic_logger\r\n\r\n## Overview\r\n\r\nSemantic Logger takes logging in Ruby to the next level by adding several new\r\ncapabilities to the commonly used Logging API:\r\n\r\nHigh Performance\r\n\r\n* Logging is performed in a separate thread so as not to slow down the application\r\n  whilst logging to one or more destinations\r\n* Supports logging from hundreds of concurrent threads in the same process\r\n\r\nDrop-in Replacement\r\n\r\n* Simple drop-in replacement for the Ruby, or the Rails loggers\r\n* Supports current common logging interface\r\n* No changes to existing to code to use new logger ( other than replacing the logger )\r\n\r\nDynamic\r\n\r\n* Increase the log level at runtime for just one class\r\n* For example enable debug level logging for a single class (logging instance)\r\n  while the program is running to get more detailed logging in production for just that class\r\n* Change the default global logging level for all classes, unless that class has\r\n  specifically been overridden above\r\n* Use UNIX signals to change the log level for a running process\r\n\r\nTagged Logging\r\n\r\n* Supply custom data to be added to every log entry within a block of code,\r\n  including libraries and existing gems\r\n* Tagged logging is critical for any high traffic site so that one can narrow\r\n  down log entries for a single call that is mixed in with log entries\r\n  from hundreds of other log entries\r\n\r\nPayload support\r\n\r\n* Aside from the regular log message, a hash payload can also be supplied with\r\n  every log entry\r\n* Very powerful when logging to NOSQL destinations that allow queries against\r\n  any data in the payload\r\n\r\nExceptions\r\n\r\n* Directly log exceptions\r\n* Semantic Logger standardizes the logging of exceptions with their backtraces\r\n  to text destinations and writes the exception elements as a hash to NOSQL\r\n  destinations\r\n\r\nBenchmarking\r\n\r\n* The performance of any block of code can be measured and logged at the same time\r\n  depending on the active log level\r\n* Supports only logging when the block of code exceeds a specified number of milli-seconds.\r\n  Makes it easy to find bottlenecks when the system suddenly slows down in production\r\n* Exceptions thrown in the block of code can also be logged so as to aid in finding\r\n  exceptions that may be discarded or hidden by the application\r\n* Benchmarked data can also be forwarded to external metric systems so that the\r\n  performance of these blocks can be measured and/or monitored over time\r\n\r\nThread Safe\r\n\r\n* Semantic Logger is completely thread safe and all methods can be called\r\n  concurrently from any thread\r\n* Tagged logging keeps any tagging data on a per-thread basis to ensure that\r\n  tags from different threads are not inter-mingled\r\n* Supports highly concurrent environments running hundreds of threads\r\n* Each appender writes all log entries sequentially in the appender thread so\r\n  that log entries are written in the correct sequence\r\n* Avoids issues that other loggers experience when multiple threads try to write\r\n  to the same log file at the same time creating partial and overwritten log\r\n  entries in the log file\r\n\r\nThread Aware\r\n\r\n* Includes the process id, and thread name or thread id in every log entry so that\r\n  log entries from different processes and even threads are easily discernable\r\n* Human readable names can be assigned to every thread for logging purposes\r\n\r\nTrace Level\r\n\r\n* :trace is a new level common in other languages and is commonly used for\r\n  logging trace level detail. It is intended for logging data at level below\r\n  :debug.\r\n* :trace can be used for logging the actual data sent or received over the network\r\n  that is rarely needed but is critical when things are not working as expected.\r\n* Since :trace can be enabled on a per class basis it can even be turned on\r\n  in production to resolve what was actually sent to an external vendor\r\n\r\nMultiple Destinations\r\n\r\n* Log to multiple destinations at the same time ( File and MongoDB, etc.. )\r\n* Each destination can also have its own log level.\r\n  For example, only log :info and above to MongoDB, or :warn and above to a\r\n  second log file\r\n\r\nSemantic Capabilities\r\n\r\n* With Semantic Logger it is simple to mix-in additional semantic information with\r\nevery log entry\r\n* The application or class name is automatically included for every log entry under\r\n  a specific logging instance\r\n* Includes the duration of blocks of code\r\n* Any hash containing context specific information such as user_id or location information\r\n\r\nBeyond Tagged Logging\r\n\r\n* Supply entire hash of custom data to be added to the payload of every log entry\r\n  within a block of code, including libraries and existing gems\r\n\r\nNOSQL Destinations\r\n\r\n* Every log entry is broken down into elements that NOSQL data stores can understand:\r\n\r\n```json\r\n{\r\n    \"_id\" : ObjectId(\"5034fa48e3f3fea945e83ef2\"),\r\n    \"time\" : ISODate(\"2012-08-22T15:27:04.409Z\"),\r\n    \"host_name\" : \"release\",\r\n    \"pid\" : 16112,\r\n    \"thread_name\" : \"main\",\r\n    \"name\" : \"UserLocator\",\r\n    \"level\" : \"debug\",\r\n    \"message\" : \"Fetch user information\",\r\n    \"duration\" : 12,\r\n    \"payload\" : {\r\n        \"user\" : \"Jack\",\r\n        \"zip_code\" : 12345,\r\n        \"location\" : \"US\"\r\n    }\r\n}\r\n```\r\n\r\nCustomizable\r\n\r\n* Custom formatting by destination\r\n* Easy to \"roll your own\" destination (Appender).\r\n  For example to log to Hadoop, Redis, etc..\r\n\r\n## Introduction\r\n\r\nSemantic Logger is a Logger that supports logging of meta-data, along with text messages\r\nto multiple appenders\r\n\r\nAn appender is a Logging destination such as a File, MongoDB collection, etc..\r\nMultiple Appenders can be active at the same time. All log entries are written\r\nto each appender.\r\n\r\nMachines can understand the logged data without having to use\r\ncomplex Regular Expressions or other text parsing techniques\r\n\r\nSemantic Logger, sits on top of existing logger implementations and can also\r\nbe used as a drop in replacement for existing Ruby loggers.\r\nThis allows the existing logging to be replaced immediately with the\r\nSemantic Logger Appenders, and over time the calls can be replaced with ones\r\nthat contain the necessary meta-data.\r\n\r\nExample of current calls:\r\n\r\n```ruby\r\nlogger.info(\"Queried users table in #{duration} ms, with a result code of #{result}\")\r\n```\r\n\r\nFor a machine to find all queries for table 'users' that took longer than\r\n100 ms, would require using a regular expression just to extract the table name\r\nand duration, then apply the necessary logic. It also assumes that the text\r\nis not changed and that matches will not be found when another log entry has\r\nsimilar text output.\r\n\r\nThis can be changed over time to:\r\n\r\n```ruby\r\nlogger.info(\"Queried table\",\r\n  :duration => duration,\r\n  :result   => result,\r\n  :table    => \"users\",\r\n  :action   => \"query\")\r\n```\r\n\r\nUsing the MongoDB appender, we can easily find all queries for table 'users'\r\nthat took longer than 100 ms:\r\n\r\n```javascript\r\ndb.logs.find({\"payload.table\":\"users\", \"payload.action\":\"query\", \"payload.duration\":{$gt:100} })\r\n```\r\n\r\nSince Semantic Logger can call existing Loggers, it does not force end-users\r\nto have to adopt a Semantic aware adapter. Although, such adapters create\r\ntremendous value in the problem monitoring and determination processes.\r\n\r\n## Logging API\r\n\r\n### Standard Logging methods\r\n\r\nThe Semantic Logger logging API supports the existing logging interface for\r\nthe Rails and Ruby Loggers. For example:\r\n\r\n```ruby\r\nlogger.info(\"Hello World\")\r\n```\r\n\r\nOr to query whether a specific log level is set\r\n\r\n```ruby\r\nlogger.info?\r\n```\r\n\r\nThe following traditional logging methods are available\r\n\r\n```ruby\r\nlogger.trace(\"Low level trace information such as data sent over a socket\")\r\nlogger.debug(\"Debugging information to aid with problem determination\")\r\nlogger.info(\"Informational message such as request received\")\r\nlogger.warn(\"Warn about something in the system\")\r\nlogger.error(\"An error occurred during processing\")\r\nlogger.fatal(\"Oh no something really bad happened\")\r\n```\r\n\r\nEach of the above calls can take additional parameters, for example:\r\n\r\n```ruby\r\nlog.info(message, payload=nil, exception=nil, &block)\r\n```\r\n\r\nParameters\r\n\r\n- message:   The text message to log.\r\n  Mandatory only if no block is supplied\r\n- payload:   Optional, either a Ruby Exception object or a Hash\r\n- exception: Optional, Ruby Exception object. Allows both an exception and a payload to be logged\r\n- block:     The optional block is executed only if the corresponding log level\r\n  is active. Can be used to prevent unnecessary calculations of debug data in\r\n  production.\r\n\r\nExamples:\r\n\r\n```ruby\r\nlogger.debug(\"Calling Supplier\")\r\n\r\nlogger.debug(\"Calling Supplier\", :request => 'update', :user => 'Jack')\r\n\r\nlogger.debug { \"A total of #{result.inject(0) {|sum, i| i+sum }} were processed\" }\r\n```\r\n\r\n## Exceptions\r\n\r\nThe Semantic Logger adds an optional parameter to the existing log methods so that\r\na corresponding Exception can be logged in a standard way\r\n\r\n```ruby\r\nbegin\r\n  # ... Code that can raise an exception\r\nrescue Exception => exception\r\n  logger.error(\"Oops external call failed\", exception)\r\n  # Re-raise or handle the exception\r\n  raise exception\r\nend\r\n```\r\n\r\n### Payload\r\n\r\nThe Semantic Logger adds an extra parameter to the existing log methods so that\r\nadditional payload can be logged, such as a Hash or a Ruby Exception object.\r\n\r\n```ruby\r\nlogger.info(\"Oops external call failed\", :result => :failed, :reason_code => -10)\r\n```\r\n\r\nThe additional payload is machine readable so that we don't have to write complex\r\nregular expressions so that a program can analyze log output. With the MongoDB\r\nappender the payload is written directly to MongoDB as part of the document and\r\nis therefore fully searchable\r\n\r\n### Benchmarking\r\n\r\nAnother common logging requirement is to measure the time it takes to execute a block\r\nof code based on the log level. For example:\r\n\r\n```ruby\r\nRails.logger.benchmark_info \"Calling external interface\" do\r\n  # Code to call external service ...\r\nend\r\n```\r\n\r\nThe following output will be written to file:\r\n\r\n    2012-08-30 15:37:29.474 I [48308:ScriptThreadProcess: script/rails] (5.2ms) Rails -- Calling external interface\r\n\r\nIf an exception is raised during the block the exception is logged\r\nat the same log level as the benchmark along with the duration and message.\r\nThe exception will flow through to the caller unchanged\r\n\r\nThe following benchmarking methods are available\r\n\r\n```ruby\r\nlogger.benchmark_trace(\"Low level trace information such as data sent over a socket\")\r\nlogger.benchmark_debug(\"Debugging information to aid with problem determination\")\r\nlogger.benchmark_info(\"Informational message such as request received\")\r\nlogger.benchmark_warn(\"Warn about something in the system\")\r\nlogger.benchmark_error(\"An error occurred during processing\")\r\nlogger.benchmark_fatal(\"Oh no something really bad happened\")\r\nlogger.benchmark(:info, \"Informational message such as request received\")\r\n```\r\n\r\nEach of the above calls can take additional parameters, for example:\r\n\r\n```ruby\r\nlog.benchmark_info(message, params=nil) do\r\n  # Measure how long it takes to run this block of code\r\nend\r\n```\r\n\r\nParameters\r\n\r\n- message: The mandatory text message to log.\r\n- params:\r\n```\r\n  :log_exception\r\n    Control whether or how an exception thrown in the block is\r\n    reported by Semantic Logger. Values:\r\n    :full\r\n      Log the exception class, message, and backtrace\r\n    :partial\r\n      Log the exception class and message\r\n      The backtrace will not be logged\r\n    :off\r\n      Any unhandled exception raised in the block will not be logged\r\n    Default: :partial\r\n\r\n  :min_duration [Float]\r\n    Only log if the block takes longer than this duration in ms\r\n    Default: 0.0\r\n\r\n  :payload [Hash]\r\n    Optional, Hash payload\r\n\r\n  :exception [Exception]\r\n    Optional, Ruby Exception object to log along with the duration of the supplied block\r\n\r\n  :duration [Float]\r\n    Optional, supply the duration in ms that is logged when a block is not supplied\r\n    If a block is not supplied then :duration is mandatory\r\n    If a block is supplied :duration is ignored\r\n\r\n  :metric [Object]\r\n    Optional, when this parameter is supplied all subscribers will be notified of this\r\n    metric, along with the Log Struct described below\r\n```\r\n\r\n### Logging levels\r\n\r\nThe following logging levels are available through Semantic Logger\r\n\r\n    :trace, :debug, :info, :warn, :error, :fatal\r\n\r\nThe log levels are listed above in the order of precedence with the most detail to the least.\r\nFor example :debug would include :info, :warn, :error, :fatal levels but not :trace\r\nAnd :fatal would only log :fatal error messages and nothing else\r\n\r\n:unknown has been mapped to :fatal for Rails and Ruby Logger\r\n\r\n:trace is a new level that is often used for tracing low level calls such\r\nas the data sent or received to external web services. It is also commonly used\r\nin the development environment for low level trace logging of methods calls etc.\r\n\r\nIf only the rails logger is being used, then :trace level calls will be logged\r\nas debug calls only if the log level is set to trace\r\n\r\n### Changing the Class name for Log Entries\r\n\r\nWhen Semantic Logger is included in a Rails project it automatically replaces the\r\nloggers for Rails, ActiveRecord::Base, ActionController::Base, and ActiveResource::Base\r\nwith wrappers that set their Class name. For example in semantic_logger/railtie.rb:\r\n\r\n```ruby\r\nActiveRecord::Base.logger = SemanticLogger[ActiveRecord]\r\n```\r\n\r\nBy replacing their loggers we now get the class name in the text logging output:\r\n\r\n    2012-08-30 15:24:13.439 D [47900:main] ActiveRecord --   SQL (12.0ms)  SELECT `schema_migrations`.`version` FROM `schema_migrations`\r\n\r\nIt is recommended to include a class specific logger for all major classes that will\r\nbe logging using the SemanticLogger::Loggable mix-in. For Example:\r\n\r\n```ruby\r\nclass ExternalSupplier\r\n  # Lazy load logger class variable on first use\r\n  include SemanticLogger::Loggable\r\n\r\n  def call_supplier(amount, name)\r\n    logger.debug \"Calculating with amount\", { :amount => amount, :name => name }\r\n\r\n    # Measure and log on completion how long the call took to the external supplier\r\n    logger.benchmark_info \"Calling external interface\" do\r\n      # Code to call the external supplier ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis will result in the log output identifying the log entry as from the ExternalSupplier class\r\n\r\n    2012-08-30 15:37:29.474 I [48308:ScriptThreadProcess: script/rails] (5.2ms) ExternalSupplier -- Calling external interface\r\n\r\n### Changing the log level for a single class at runtime\r\n\r\nSince the logger is class specific, its log level can be changed dynamically at runtime.\r\nFor example, to temporarily set the log level to :trace to diagnose an issue:\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\n\r\nSemanticLogger.default_level = :info\r\nSemanticLogger.add_appender('example.log')\r\n\r\nclass ExternalSupplier\r\n  # Lazy load logger class variable on first use\r\n  include SemanticLogger::Loggable\r\n\r\n  def call_supplier(amount, name)\r\n    logger.trace \"Calculating with amount\", { :amount => amount, :name => name }\r\n\r\n    # Measure and log on completion how long the call took to the external supplier\r\n    logger.benchmark_info \"Calling external interface\" do\r\n      # Code to call the external supplier ...\r\n    end\r\n  end\r\nend\r\n\r\n# Create and use the class\r\nsupplier = ExternalSupplier.new\r\nsupplier.call_supplier(100, 'Jack')\r\n\r\n# Now change the log level to :trace\r\nExternalSupplier.logger.level = :trace\r\n\r\n# Call the supplier, this time including trace level messages\r\nsupplier.call_supplier(100, 'Jack')\r\n\r\n# Change the log level back to the default level\r\nExternalSupplier.logger.level = SemanticLogger.default_level\r\n```\r\n\r\nBelow is the output from the above example showing the :trace log level message\r\nthat was written during the second call to the ExternalSupplier:\r\n\r\n```\r\n2013-11-07 16:19:26.496 I [35674:main] (0.0ms) ExternalSupplier -- Calling external interface\r\n\r\n2013-11-07 16:19:26.683 T [35674:main] ExternalSupplier -- Calculating with amount -- {:amount=>100, :name=>\"Jack\"}\r\n2013-11-07 16:19:26.683 I [35674:main] (0.0ms) ExternalSupplier -- Calling external interface\r\n```\r\n\r\n### Change the global default logging level at runtime\r\n\r\nLog levels can be changed using signals on operating systems that support them.\r\nThis allows log levels to be changed externally without requiring a restart\r\nof the running process.\r\n\r\nWhen the signal is raised, the global default log level rotates through the following\r\nlog levels in the following order, starting from the current global default level:\r\n\r\n```ruby\r\n  :warn, :info, :debug, :trace\r\n```\r\n\r\nIf the current level is :trace it wraps around back to :warn\r\n\r\nExample:\r\n\r\n```\r\nkill -SIGUSR2 1234\r\n```\r\n\r\n#### Enabling Log Level Signal handler\r\n\r\nOn startup SemanticLogger does not register any signals so that it does not\r\ninterfere with any existing signal handlers. In order to enable the above log level\r\nchanges the signal handler must be registered by calling `SemanticLogger.add_signal_handler`\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\n\r\n# Enable signal handling for this process\r\nSemanticLogger.add_signal_handler('USR2')\r\n\r\nSemanticLogger.add_appender('development.log')\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\n```\r\n\r\nNote: The changes to the logging level will not change for any classes where the\r\nlog_level was set explicity within the application itself. The above signal only changes\r\nthe global default level, which is used by loggers when their log level has not been changed.\r\n\r\n#### Change the log level without using signals\r\n\r\nIf the application has another means of communicating without needing signals,\r\nthe global default log level can be modified using `SemanticLogger.default_level=`\r\n\r\n```ruby\r\n# Change the global default logging level for active loggers\r\nSemanticLogger.default_level = :debug\r\n```\r\n\r\n### Tagged Logging\r\n\r\nSemantic Logger allows any Ruby or Rails program to also include tagged logging.\r\n\r\nThis means that any logging performed within a block, including any called\r\nlibraries or gems to include the specified tag with every log entry.\r\n\r\nUsing Tagged logging is critical in any highly concurrent environment so that\r\none can quickly find all related log entries across all levels of code, and even\r\nacross threads\r\n\r\n```ruby\r\nlogger.tagged(tracking_number) do\r\n  logger.debug(\"Hello World\")\r\n  # ...\r\nend\r\n```\r\n\r\n### Beyond Tagged Logging\r\n\r\nBlocks of code can be tagged with not only values, but can be tagged with\r\nentire hashes of data. The additional hash of data will be merged into\r\nthe payload of every log entry\r\n\r\nFor example every corresponding log entry could include a hash containing\r\na user_id, name, region, zip_code, tracking_number, etc...\r\n\r\n```ruby\r\nlogger.with_payload(:user => 'Jack', :zip_code => 12345) do\r\n  logger.debug(\"Hello World\")\r\n  # ...\r\nend\r\n```\r\n\r\n### Named threads\r\n\r\nSemanticLogger logs the name or id of the thread in every log message.\r\n\r\nOn Ruby MRI the thread name is by default the thread's object_id, For example: 70184354571980\r\n\r\n```\r\n2013-11-07 16:25:14.279627 I [35841:70184354571980] (0.0ms) ExternalSupplier -- Calling external interface\r\n```\r\n\r\nTo set a custom name for any thread so that it shows up in the logger:\r\n\r\n```ruby\r\nThread.current.name = \"User calculation thread 32\"\r\n```\r\n\r\nSample output:\r\n\r\n```\r\n2013-11-07 16:26:02.744139 I [35841:User calculation thread 32] (0.0ms) ExternalSupplier -- Calling external interface\r\n```\r\n\r\nWhen running JRuby, Thread.current.name will also set the underlying thread name in the JVM\r\nwhich is very useful when monitoring the JVM via JMX using tools such as jconsole.\r\n\r\n#### NOTE:\r\n\r\nMake sure that the assigned thread name is unique otherwise it will be difficult\r\nto distinguish between concurrently running threads if they have the same name.\r\n\r\nFor example, use the current thread object_id to ensure uniqueness:\r\n\r\n```ruby\r\nThread.current.name = \"Worker Thread:#{Thread.current.object_id}\"\r\n```\r\n\r\n### Metrics integration\r\n\r\nIn production environments it is often necessary to not only measure the performance of a\r\nblock of code using for example:\r\n\r\n```ruby\r\nlogger.benchmark_info \"Calling external interface\" do\r\n  # Code to call the external supplier ...\r\nend\r\n```\r\n\r\nA single subscriber can be defined to collect all the metrics and forward them\r\nfor example to NewRelic:\r\n\r\n```ruby\r\n# config/initializers/semantic_logger_metrics.rb\r\nSemanticLogger.on_metric do |log_struct|\r\n  ::NewRelic::Agent.record_metric(log_struct.metric, log_struct.duration)\r\nend\r\n```\r\n\r\nAdd the :metric option to the log entry as follows:\r\n\r\n```ruby\r\nlogger.benchmark_info \"Calling external interface\", :metric => 'Custom/slow_action/beginning_work' do\r\n  # Code to call the external supplier ...\r\nend\r\n```\r\n\r\n## Standalone SemanticLogger\r\n\r\nWhen using SemanticLogger inside of Rails all we need to do is include the\r\nrails_semantic_logger gem and the default Rails logger will be replaced with\r\nSemantic Logger.\r\n\r\nIn a stand-alone or non-rails environment we can easily log to a file called\r\n'development.log' as follows:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.add_appender('development.log')\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\n```\r\n\r\nBy default it will only log :info and above, to log everything to the log file:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender('development.log')\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\nlogger.trace \"Low level trace information\"\r\n```\r\n\r\nBy supplying multiple appenders Semantic Logger can write to multiple destinations\r\nat the same time. For example, log to a file and the screen:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender('development.log')\r\nSemanticLogger.add_appender(STDOUT)\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\nlogger.trace \"Low level trace information\"\r\n```\r\n\r\nTo reduce the log level of logging to STDOUT to just :info and above, add the\r\nlog_level such as :info as the second parameter when adding the appender:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender('development.log')\r\nSemanticLogger.add_appender(STDOUT, :info)\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\nlogger.trace \"Low level trace information\"\r\n```\r\n\r\nTo log :debug and above to a log file, :error and above to $stderr, and :info\r\nand above to MongoDB:\r\n```ruby\r\nrequire 'semantic_logger'\r\nrequire 'mongo'\r\n\r\nSemanticLogger.default_level = :debug\r\nSemanticLogger.add_appender('development.log')\r\nSemanticLogger.add_appender($stderr, :error)\r\n\r\nmongo_appender = SemanticLogger::Appender::MongoDB.new(\r\n  :db              => Mongodb::Connection.new['production_logging'],\r\n  :collection_size => 25.gigabytes\r\n)\r\nSemanticLogger.add_appender(mongo_appender, :info)\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\nlogger.trace \"Low level trace information\"\r\nlogger.error \"Oops an error occurred\"\r\nlogger.info(\"Login time\", :user => 'Mary', :duration => 230, :ip_address=>'192.168.0.1')\r\n```\r\n\r\nWhen starting out with Semantic Logger it can be useful to gain all the benefits\r\nof Semantic Logger and still continue to log to an existing logger:\r\n```ruby\r\nrequire 'logger'\r\nrequire 'semantic_logger'\r\n\r\n# Built-in Ruby logger\r\nlog = Logger.new(STDOUT)\r\nlog.level = Logger::DEBUG\r\n\r\nSemanticLogger.default_level = :debug\r\nSemanticLogger.add_appender(log)\r\n\r\nlogger = SemanticLogger['Example']\r\nlogger.info \"Hello World\"\r\nlogger.debug(\"Login time\", :user => 'Joe', :duration => 100, :ip_address=>'127.0.0.1')\r\n```\r\n\r\nIt is recommended that every class or module have it's own logging instance.\r\nThis can be achieved by including SemanticLogger::Loggable:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender('development.log')\r\n\r\nclass ExternalSupplier\r\n  # Makes available a class and instance level logger\r\n  #    ExternalSupplier.logger and ExternalSupplier#logger\r\n  include SemanticLogger::Loggable\r\n\r\n  # logger class method example\r\n  def self.hostname=(hostname)\r\n    logger.debug \"Setting hostname to #{hostname}\"\r\n    @@hostname = hostname\r\n  end\r\n\r\n  # logger instance method example\r\n  def call_supplier(amount, name)\r\n    logger.debug \"Calculating with amount\", { :amount => amount, :name => name }\r\n\r\n    # Measure and log on completion how long the call took to the external supplier\r\n    logger.benchmark_info \"Calling external interface\" do\r\n      # Code to call the external supplier ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Logging to Syslog\r\n\r\nLog to a local Syslog:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender(SemanticLogger::Appender::Syslog.new)\r\n```\r\n\r\nLog to a local file and to a remote Syslog server such as syslog-ng over TCP:\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\nSemanticLogger.add_appender('development.log')\r\nSemanticLogger.add_appender(SemanticLogger::Appender::Syslog.new(:server => 'tcp://myloghost:514'))\r\n```\r\n\r\n## Configuration\r\n\r\nThe Semantic Logger follows the principle where multiple appenders can be active\r\nat the same time. For example, this allows one to log to MongoDB and the Rails\r\nlog file at the same time.\r\n\r\n### Rails Configuration\r\n\r\nTo automatically replace the Rails logger with Semantic Logger use the gem [rails_semantic_logger](http://github.com/reidmorrison/rails_semantic_logger)\r\n\r\n## Log Struct\r\n\r\nInternally all log messages are passed around in a Log Struct. In order\r\nto write your own custom formatter or log appender it is necessary to understand\r\nthe fields:\r\n\r\n```ruby\r\nLog = Struct.new(:level, :thread_name, :name, :message, :payload, :time, :duration, :tags, :level_index, :exception, :metric)\r\n```\r\nlevel [Symbol]\r\n\r\n* Log level of the supplied log call\r\n* :trace, :debug, :info, :warn, :error, :fatal\r\n\r\nthread_name [String]\r\n\r\n* Name or id of the thread in which the logging call was called\r\n\r\nname [String]\r\n\r\n* Class name supplied to the logging instance\r\n\r\nmessage [String]\r\n\r\n* Text message to be logged\r\n\r\npayload [Hash|Exception]\r\n\r\n* Optional Hash or Ruby Exception object to be logged\r\n\r\ntime [Time]\r\n\r\n* The time at which the log entry was created\r\n\r\nduration [Float]\r\n\r\n* The time taken in milli-seconds to complete a benchmark call\r\n\r\ntags [Array<String>]\r\n\r\n* Any tags active on the thread when the log call was made\r\n\r\nlevel_index [Integer]\r\n\r\n* Internal use only. Index of the log level\r\n\r\nmetric [Object]\r\n\r\n* Object supplied when the benchmark api was called\r\n\r\n### Mixing Logging Levels\r\n\r\nIt is sometimes useful to log a subset of the log messages to a separate file\r\nor appender. For example, log :error and :fatal level messages to a special\r\nerror file.\r\n\r\nBelow is a stand-alone example that better shows this behavior:\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\n\r\n# Set default log level for new logger instances\r\nSemanticLogger.default_level = :info\r\n\r\n# Log all warning messages and above to warnings.log\r\nSemanticLogger.add_appender('log/warnings.log', :warn)\r\n\r\n# Log all trace messages and above to trace.log\r\nSemanticLogger.add_appender('log/trace.log', :trace)\r\n\r\nlogger = SemanticLogger['MyClass']\r\nlogger.level = :trace\r\nlogger.trace \"This is a trace message\"\r\nlogger.info \"This is an info message\"\r\nlogger.warn \"This is a warning message\"\r\n```\r\n\r\nThe output is as follows:\r\n```bash\r\n==> trace.log <==\r\n2013-08-02 14:15:56.733532 T [35669:70176909690580] MyClass -- This is a trace message\r\n2013-08-02 14:15:56.734273 I [35669:70176909690580] MyClass -- This is an info message\r\n2013-08-02 14:15:56.735273 W [35669:70176909690580] MyClass -- This is a warning message\r\n\r\n==> warnings.log <==\r\n2013-08-02 14:15:56.735273 W [35669:70176909690580] MyClass -- This is a warning message\r\n```\r\n\r\n### Custom Formatters\r\n\r\nThe formatting for each appender can be replaced with custom code. To replace the\r\nexisting formatter supply a block of code when creating the appender.\r\n\r\nExample: Formatter that just returns the Log Struct\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\n\r\nSemanticLogger.default_level = :trace\r\n\r\nSemanticLogger.add_appender(STDOUT) do |log|\r\n # This formatter just returns the log struct as a string\r\n  log.inspect\r\nend\r\n\r\nlogger = SemanticLogger['Hello']\r\nlogger.info \"Hello World\"\r\n```\r\nOutput:\r\n\r\n    #<struct SemanticLogger::Base::Log level=:info, thread_name=70167090649820, name=\"Hello\", message=\"Hello World\", payload=nil, time=2012-10-24 10:09:33 -0400, duration=nil, tags=nil, level_index=2>\r\n\r\n\r\nExample: Replace the default log file formatter\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\nSemanticLogger.default_level = :trace\r\n\r\nSemanticLogger.add_appender('development.log') do |log|\r\n  tags = log.tags.collect { |tag| \"[#{tag}]\" }.join(\" \") + \" \" if log.tags && (log.tags.size > 0)\r\n\r\n  message = log.message.to_s\r\n  message << \" -- \" << log.payload.inspect if log.payload\r\n  message << \" -- \" << \"#{log.exception.class}: #{log.exception.message}\\n#{(log.exception.backtrace || []).join(\"\\n\")}\" if log.exception\r\n\r\n  duration_str = log.duration ? \"(#{'%.1f' % log.duration}ms) \" : ''\r\n\r\n  \"#{SemanticLogger::Appender::Base.formatted_time(log.time)} #{log.level.to_s[0..0].upcase} [#{$$}:#{log.thread_name}] #{tags}#{duration_str}#{log.name} -- #{message}\"\r\nend\r\n```\r\n\r\nExample: Replace the default MongoDB formatter\r\n\r\n```ruby\r\n# Log to MongoDB and supply a custom document formatter\r\nmongodb_appender = SemanticLogger::Appender::MongoDB.new(\r\n  :db              => Cache::Work.db,\r\n  :collection_size => 25.gigabytes\r\n) do |log|\r\n    # Return a document (Hash) of the data to be saved to MongoDB\r\n    document = {\r\n      :time        => log.time,\r\n      :host_name   => SemanticLogger::Appender::MongoDB.host_name,\r\n      :pid         => $PID,\r\n      :thread_name => log.thread_name,\r\n      :name        => log.name,\r\n      :level       => log.level,\r\n      :level_index => log.level_index,\r\n    }\r\n    document[:application] = 'MyApplication'\r\n    document[:message]     = SemanticLogger::Appender::MongoDB.strip_colorizing(log.message) if log.message\r\n    document[:duration]    = log.duration if log.duration\r\n    document[:tags]        = log.tags if log.tags && (log.tags.size > 0)\r\n    document[:payload]     = log.payload if log.payload\r\n    document[:exception]   = {\r\n      :name        => log.exception.class.name,\r\n      :message     => log.exception.message,\r\n      :stack_trace => log.exception.backtrace\r\n    } if log.exception\r\n    document\r\nend\r\nSemanticLogger.add_appender(mongodb_appender)\r\n```\r\n\r\n## Performance\r\n\r\nThe traditional logging implementations write their log information to file in the\r\nsame thread of execution as the program itself. This means that for every log entry\r\nthe program has to wait for the data to be written.\r\n\r\nWith Semantic Logger it uses a dedicated thread for logging so that writing to\r\nthe log file or other appenders does not hold up program execution.\r\n\r\nAlso, since the logging is in this separate thread there is no impact to program\r\nexecution if we decided to add another appender.\r\nFor example, log to both a file and a MongoDB collection.\r\n\r\n## Log Rotation\r\n\r\nSince the log file is not re-opened with every call, when the log file needs\r\nto be rotated, use a copy-truncate operation over deleting the file.\r\n\r\n## Why Semantic logging?\r\n\r\nJust as there is the initiative to add Semantic information to data on the web\r\nso that computers can directly understand the content without having to resort\r\nto complex regular expressions or machine learning techniques, it is important\r\nto be able to do the same with log files or data.\r\n\r\nSemantic Logger allows every log entry to have not only a message, but a payload\r\nthat can be written to a file or a NOSQL destination.\r\n\r\nOnce the logging data is in the NOSQL data store it can be queried quickly and\r\nefficiently. Some SQL data stores also allow complex data types that could be used\r\nfor storing and querying the logging data\r\n\r\nBefore writing SemanticLogger all of the following logging frameworks were thoroughly\r\nevaluated. None of them met the above Semantic requirements, or the performance requirements\r\nof hundreds of threads all logging at the same time:\r\nlogback, logging, log4r, central_logger, whoops\r\n\r\n## Architecture & Performance\r\n\r\nIn order to ensure that logging does not hinder the performance of the application\r\nall log entries are written to thread-safe Queue. A separate thread is responsible\r\nfor writing the log entries to each of the appenders.\r\n\r\nIn this way formatting and disk or network write delays will not affect the\r\nperformance of the application. Also adding more than one appender does not affect\r\nthe runtime performance of the application.\r\n\r\nThe logging thread is automatically started on initialization. When the program\r\nterminates it will call flush on each of the appenders.\r\n\r\nCalling SemanticLogger::Logger#flush will wait until all outstanding log messages\r\nhave been written and flushed to their respective appenders before returning.\r\n\r\n## Write your own Appender\r\n\r\nTo write your own appender it should meet the following requirements:\r\n\r\n* Inherit from SemanticLogger::Base\r\n* In the initializer connect to the resource being logged to\r\n* Implement #log(log) which needs to write to the relevant resource\r\n* Implement #flush if the resource can be flushed\r\n* Write a test for the new appender\r\n\r\nThe #log method takes the log struct as a parameter which is described above.\r\n\r\nBasic outline for an Appender:\r\n\r\n```ruby\r\nrequire 'semantic_logger'\r\n\r\nclass SimpleAppender < SemanticLogger::Appender::Base\r\n  def initialize(level=nil, &block)\r\n    # Set the log level and formatter if supplied\r\n    super(level, &block)\r\n  end\r\n\r\n  # Display the log struct and the text formatted output\r\n  def log(log)\r\n    p log\r\n    puts formatter.call(log)\r\n  end\r\n\r\n  # Optional\r\n  def flush\r\n    puts \"Flush :)\"\r\n  end\r\nend\r\n```\r\n\r\nSample program calling the above appender:\r\n```ruby\r\nSemanticLogger.default_level = :trace\r\n# Log to file dev.log\r\nSemanticLogger.add_appender('dev.log')\r\n# Also log the above sample appender\r\nSemanticLogger.add_appender(SimpleAppender.new)\r\n\r\nlogger = SemanticLogger['Hello']\r\nlogger.info \"Hello World\"\r\n```\r\n\r\nLook at the [existing appenders](https://github.com/reidmorrison/semantic_logger/tree/master/lib/semantic_logger/appender) for good examples\r\n\r\nTo have your appender included in the standard list of appenders, submit it along\r\nwith complete working tests.\r\nSee the [MongoDB Appender Test](https://github.com/reidmorrison/semantic_logger/blob/master/test/appender_mongodb_test.rb) for an example.\r\n\r\n## Dependencies\r\n\r\nSee [.travis.yml](https://github.com/reidmorrison/semantic_logger/.travis.yml) for the list of tested Ruby platforms\r\n\r\nThe following gems are only required when their corresponding appenders are being used,\r\nand are therefore not automatically included by this gem:\r\n- MongoDB Appender: mongo 1.9.2 or above\r\n- Syslog Appender: syslog_protocol 0.9.2 or above\r\n- Syslog Appender to a remote syslogng server over TCP or UDP: resilient_socket 0.5.0 or above\r\n\r\n## Install\r\n\r\n    gem install semantic_logger\r\n\r\n## Upgrade Notes:\r\n\r\nAs of SemanticLogger V2.0 the Rails logging is no longer automatically replaced\r\nwhen including SemanticLogger. Include the [rails_semantic_logger](http://github.com/reidmorrison/rails_semantic_logger)\r\ngem to replace the Rails default logger with SemanticLogger\r\n\r\nMeta\r\n----\r\n\r\n* Code: `git clone git://github.com/reidmorrison/semantic_logger.git`\r\n* Home: <https://github.com/reidmorrison/semantic_logger>\r\n* Bugs: <http://github.com/reidmorrison/semantic_logger/issues>\r\n* Gems: <http://rubygems.org/gems/semantic_logger>\r\n\r\nThis project uses [Semantic Versioning](http://semver.org/).\r\n\r\nAuthor\r\n-------\r\n\r\nReid Morrison :: reidmo@gmail.com :: @reidmorrison\r\n\r\nContributors\r\n------------\r\n\r\nMarc Bellingrath :: marrrc.b@gmail.com\r\n\r\nLicense\r\n-------\r\n\r\nCopyright 2012, 2013, 2014 Reid Morrison\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}