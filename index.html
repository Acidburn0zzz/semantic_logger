<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Semantic logger by reidmorrison</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Semantic logger</h1>
        <h2>Scalable, next generation logging for Ruby</h2>
        <a href="https://github.com/reidmorrison/semantic_logger" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="semantic_logger-" class="anchor" href="#semantic_logger-"><span class="octicon octicon-link"></span></a>semantic_logger <a href="http://travis-ci.org/reidmorrison/semantic_logger"><img src="https://secure.travis-ci.org/reidmorrison/semantic_logger.png?branch=master" alt="Build Status"></a>
</h1>

<p>Next generation logging system for Ruby to support highly concurrent, high throughput, low latency systems</p>

<ul>
<li><a href="http://github.com/reidmorrison/semantic_logger">http://github.com/reidmorrison/semantic_logger</a></li>
</ul><h2>
<a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Semantic Logger takes logging in Ruby to the next level by adding several new
capabilities to the commonly used Logging API:</p>

<p>High Performance</p>

<ul>
<li>Logging is performed in a separate thread so as not to slow down the application
whilst logging to one or more destinations</li>
<li>Supports logging from hundreds of concurrent threads in the same process</li>
</ul><p>Drop-in Replacement</p>

<ul>
<li>Simple drop-in replacement for the Ruby, or the Rails loggers</li>
<li>Supports current common logging interface</li>
<li>No changes to existing to code to use new logger ( other than replacing the logger )</li>
</ul><p>Dynamic</p>

<ul>
<li>Increase the log level at runtime for just one class</li>
<li>For example enable debug level logging for a single class (logging instance)
while the program is running to get more detailed logging in production for just that class</li>
<li>Change the default global logging level for all classes, unless that class has
specifically been overridden above</li>
<li>Use UNIX signals to change the log level for a running process</li>
</ul><p>Tagged Logging</p>

<ul>
<li>Supply custom data to be added to every log entry within a block of code,
including libraries and existing gems</li>
<li>Tagged logging is critical for any high traffic site so that one can narrow
down log entries for a single call that is mixed in with log entries
from hundreds of other log entries</li>
</ul><p>Payload support</p>

<ul>
<li>Aside from the regular log message, a hash payload can also be supplied with
every log entry</li>
<li>Very powerful when logging to NOSQL destinations that allow queries against
any data in the payload</li>
</ul><p>Exceptions</p>

<ul>
<li>Directly log exceptions</li>
<li>Semantic Logger standardizes the logging of exceptions with their backtraces
to text destinations and writes the exception elements as a hash to NOSQL
destinations</li>
</ul><p>Benchmarking</p>

<ul>
<li>The performance of any block of code can be measured and logged at the same time
depending on the active log level</li>
<li>Supports only logging when the block of code exceeds a specified number of milli-seconds.
Makes it easy to find bottlenecks when the system suddenly slows down in production</li>
<li>Exceptions thrown in the block of code can also be logged so as to aid in finding
exceptions that may be discarded or hidden by the application</li>
<li>Benchmarked data can also be forwarded to external metric systems so that the
performance of these blocks can be measured and/or monitored over time</li>
</ul><p>Thread Safe</p>

<ul>
<li>Semantic Logger is completely thread safe and all methods can be called
concurrently from any thread</li>
<li>Tagged logging keeps any tagging data on a per-thread basis to ensure that
tags from different threads are not inter-mingled</li>
<li>Supports highly concurrent environments running hundreds of threads</li>
<li>Each appender writes all log entries sequentially in the appender thread so
that log entries are written in the correct sequence</li>
<li>Avoids issues that other loggers experience when multiple threads try to write
to the same log file at the same time creating partial and overwritten log
entries in the log file</li>
</ul><p>Thread Aware</p>

<ul>
<li>Includes the process id, and thread name or thread id in every log entry so that
log entries from different processes and even threads are easily discernable</li>
<li>Human readable names can be assigned to every thread for logging purposes</li>
</ul><p>Trace Level</p>

<ul>
<li>:trace is a new level common in other languages and is commonly used for
logging trace level detail. It is intended for logging data at level below
:debug.</li>
<li>:trace can be used for logging the actual data sent or received over the network
that is rarely needed but is critical when things are not working as expected.</li>
<li>Since :trace can be enabled on a per class basis it can even be turned on
in production to resolve what was actually sent to an external vendor</li>
</ul><p>Multiple Destinations</p>

<ul>
<li>Log to multiple destinations at the same time ( File and MongoDB, etc.. )</li>
<li>Each destination can also have its own log level.
For example, only log :info and above to MongoDB, or :warn and above to a
second log file</li>
</ul><p>Semantic Capabilities</p>

<ul>
<li>With Semantic Logger it is simple to mix-in additional semantic information with
every log entry</li>
<li>The application or class name is automatically included for every log entry under
a specific logging instance</li>
<li>Includes the duration of blocks of code</li>
<li>Any hash containing context specific information such as user_id or location information</li>
</ul><p>Beyond Tagged Logging</p>

<ul>
<li>Supply entire hash of custom data to be added to the payload of every log entry
within a block of code, including libraries and existing gems</li>
</ul><p>NOSQL Destinations</p>

<ul>
<li>Every log entry is broken down into elements that NOSQL data stores can understand:</li>
</ul><div class="highlight highlight-json"><pre><span class="p">{</span>
    <span class="nt">"_id"</span> <span class="p">:</span> <span class="err">ObjectId(</span><span class="s2">"5034fa48e3f3fea945e83ef2"</span><span class="err">)</span><span class="p">,</span>
    <span class="nt">"time"</span> <span class="p">:</span> <span class="err">ISODate(</span><span class="s2">"2012-08-22T15:27:04.409Z"</span><span class="err">)</span><span class="p">,</span>
    <span class="nt">"host_name"</span> <span class="p">:</span> <span class="s2">"release"</span><span class="p">,</span>
    <span class="nt">"pid"</span> <span class="p">:</span> <span class="mi">16112</span><span class="p">,</span>
    <span class="nt">"thread_name"</span> <span class="p">:</span> <span class="s2">"main"</span><span class="p">,</span>
    <span class="nt">"name"</span> <span class="p">:</span> <span class="s2">"UserLocator"</span><span class="p">,</span>
    <span class="nt">"level"</span> <span class="p">:</span> <span class="s2">"debug"</span><span class="p">,</span>
    <span class="nt">"message"</span> <span class="p">:</span> <span class="s2">"Fetch user information"</span><span class="p">,</span>
    <span class="nt">"duration"</span> <span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
    <span class="nt">"payload"</span> <span class="p">:</span> <span class="p">{</span>
        <span class="nt">"user"</span> <span class="p">:</span> <span class="s2">"Jack"</span><span class="p">,</span>
        <span class="nt">"zip_code"</span> <span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
        <span class="nt">"location"</span> <span class="p">:</span> <span class="s2">"US"</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Customizable</p>

<ul>
<li>Custom formatting by destination</li>
<li>Easy to "roll your own" destination (Appender).
For example to log to Hadoop, Redis, etc..</li>
</ul><h2>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>Semantic Logger is a Logger that supports logging of meta-data, along with text messages
to multiple appenders</p>

<p>An appender is a Logging destination such as a File, MongoDB collection, etc..
Multiple Appenders can be active at the same time. All log entries are written
to each appender.</p>

<p>Machines can understand the logged data without having to use
complex Regular Expressions or other text parsing techniques</p>

<p>Semantic Logger, sits on top of existing logger implementations and can also
be used as a drop in replacement for existing Ruby loggers.
This allows the existing logging to be replaced immediately with the
Semantic Logger Appenders, and over time the calls can be replaced with ones
that contain the necessary meta-data.</p>

<p>Example of current calls:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Queried users table in </span><span class="si">#{</span><span class="n">duration</span><span class="si">}</span><span class="s2"> ms, with a result code of </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>

<p>For a machine to find all queries for table 'users' that took longer than
100 ms, would require using a regular expression just to extract the table name
and duration, then apply the necessary logic. It also assumes that the text
is not changed and that matches will not be found when another log entry has
similar text output.</p>

<p>This can be changed over time to:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Queried table"</span><span class="p">,</span>
  <span class="ss">:duration</span> <span class="o">=&gt;</span> <span class="n">duration</span><span class="p">,</span>
  <span class="ss">:result</span>   <span class="o">=&gt;</span> <span class="n">result</span><span class="p">,</span>
  <span class="ss">:table</span>    <span class="o">=&gt;</span> <span class="s2">"users"</span><span class="p">,</span>
  <span class="ss">:action</span>   <span class="o">=&gt;</span> <span class="s2">"query"</span><span class="p">)</span>
</pre></div>

<p>Using the MongoDB appender, we can easily find all queries for table 'users'
that took longer than 100 ms:</p>

<div class="highlight highlight-javascript"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">logs</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span><span class="s2">"payload.table"</span><span class="o">:</span><span class="s2">"users"</span><span class="p">,</span> <span class="s2">"payload.action"</span><span class="o">:</span><span class="s2">"query"</span><span class="p">,</span> <span class="s2">"payload.duration"</span><span class="o">:</span><span class="p">{</span><span class="nx">$gt</span><span class="o">:</span><span class="mi">100</span><span class="p">}</span> <span class="p">})</span>
</pre></div>

<p>Since Semantic Logger can call existing Loggers, it does not force end-users
to have to adopt a Semantic aware adapter. Although, such adapters create
tremendous value in the problem monitoring and determination processes.</p>

<h2>
<a name="logging-api" class="anchor" href="#logging-api"><span class="octicon octicon-link"></span></a>Logging API</h2>

<h3>
<a name="standard-logging-methods" class="anchor" href="#standard-logging-methods"><span class="octicon octicon-link"></span></a>Standard Logging methods</h3>

<p>The Semantic Logger logging API supports the existing logging interface for
the Rails and Ruby Loggers. For example:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
</pre></div>

<p>Or to query whether a specific log level is set</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info?</span>
</pre></div>

<p>The following traditional logging methods are available</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">"Low level trace information such as data sent over a socket"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Debugging information to aid with problem determination"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Informational message such as request received"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"Warn about something in the system"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">"An error occurred during processing"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="s2">"Oh no something really bad happened"</span><span class="p">)</span>
</pre></div>

<p>Each of the above calls can take additional parameters, for example:</p>

<div class="highlight highlight-ruby"><pre><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">payload</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</pre></div>

<p>Parameters</p>

<ul>
<li>message:   The text message to log.
Mandatory only if no block is supplied</li>
<li>payload:   Optional, either a Ruby Exception object or a Hash</li>
<li>exception: Optional, Ruby Exception object. Allows both an exception and a payload to be logged</li>
<li>block:     The optional block is executed only if the corresponding log level
is active. Can be used to prevent unnecessary calculations of debug data in
production.</li>
</ul><p>Examples:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Calling Supplier"</span><span class="p">)</span>

<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Calling Supplier"</span><span class="p">,</span> <span class="ss">:request</span> <span class="o">=&gt;</span> <span class="s1">'update'</span><span class="p">,</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="s1">'Jack'</span><span class="p">)</span>

<span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="p">{</span> <span class="s2">"A total of </span><span class="si">#{</span><span class="n">result</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="o">+</span><span class="n">sum</span> <span class="si">}</span><span class="s2">} were processed"</span> <span class="p">}</span>
</pre></div>

<h2>
<a name="exceptions" class="anchor" href="#exceptions"><span class="octicon octicon-link"></span></a>Exceptions</h2>

<p>The Semantic Logger adds an optional parameter to the existing log methods so that
a corresponding Exception can be logged in a standard way</p>

<div class="highlight highlight-ruby"><pre><span class="k">begin</span>
  <span class="c1"># ... Code that can raise an exception</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">exception</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">"Oops external call failed"</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="c1"># Re-raise or handle the exception</span>
  <span class="k">raise</span> <span class="n">exception</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="payload" class="anchor" href="#payload"><span class="octicon octicon-link"></span></a>Payload</h3>

<p>The Semantic Logger adds an extra parameter to the existing log methods so that
additional payload can be logged, such as a Hash or a Ruby Exception object.</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Oops external call failed"</span><span class="p">,</span> <span class="ss">:result</span> <span class="o">=&gt;</span> <span class="ss">:failed</span><span class="p">,</span> <span class="ss">:reason_code</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

<p>The additional payload is machine readable so that we don't have to write complex
regular expressions so that a program can analyze log output. With the MongoDB
appender the payload is written directly to MongoDB as part of the document and
is therefore fully searchable</p>

<h3>
<a name="benchmarking" class="anchor" href="#benchmarking"><span class="octicon octicon-link"></span></a>Benchmarking</h3>

<p>Another common logging requirement is to measure the time it takes to execute a block
of code based on the log level. For example:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Rails</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span> <span class="k">do</span>
  <span class="c1"># Code to call external service ...</span>
<span class="k">end</span>
</pre></div>

<p>The following output will be written to file:</p>

<pre><code>2012-08-30 15:37:29.474 I [48308:ScriptThreadProcess: script/rails] (5.2ms) Rails -- Calling external interface
</code></pre>

<p>If an exception is raised during the block the exception is logged
at the same log level as the benchmark along with the duration and message.
The exception will flow through to the caller unchanged</p>

<p>The following benchmarking methods are available</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">benchmark_trace</span><span class="p">(</span><span class="s2">"Low level trace information such as data sent over a socket"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark_debug</span><span class="p">(</span><span class="s2">"Debugging information to aid with problem determination"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span><span class="p">(</span><span class="s2">"Informational message such as request received"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark_warn</span><span class="p">(</span><span class="s2">"Warn about something in the system"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark_error</span><span class="p">(</span><span class="s2">"An error occurred during processing"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark_fatal</span><span class="p">(</span><span class="s2">"Oh no something really bad happened"</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"Informational message such as request received"</span><span class="p">)</span>
</pre></div>

<p>Each of the above calls can take additional parameters, for example:</p>

<div class="highlight highlight-ruby"><pre><span class="n">log</span><span class="o">.</span><span class="n">benchmark_info</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># Measure how long it takes to run this block of code</span>
<span class="k">end</span>
</pre></div>

<p>Parameters</p>

<ul>
<li>message: The mandatory text message to log.</li>
<li>params:</li>
</ul><pre><code>  :log_exception
    Control whether or how an exception thrown in the block is
    reported by Semantic Logger. Values:
    :full
      Log the exception class, message, and backtrace
    :partial
      Log the exception class and message
      The backtrace will not be logged
    :off
      Any unhandled exception raised in the block will not be logged
    Default: :partial

  :min_duration [Float]
    Only log if the block takes longer than this duration in ms
    Default: 0.0

  :payload [Hash]
    Optional, Hash payload

  :exception [Exception]
    Optional, Ruby Exception object to log along with the duration of the supplied block

  :duration [Float]
    Optional, supply the duration in ms that is logged when a block is not supplied
    If a block is not supplied then :duration is mandatory
    If a block is supplied :duration is ignored

  :metric [Object]
    Optional, when this parameter is supplied all subscribers will be notified of this
    metric, along with the Log Struct described below
</code></pre>

<h3>
<a name="logging-levels" class="anchor" href="#logging-levels"><span class="octicon octicon-link"></span></a>Logging levels</h3>

<p>The following logging levels are available through Semantic Logger</p>

<pre><code>:trace, :debug, :info, :warn, :error, :fatal
</code></pre>

<p>The log levels are listed above in the order of precedence with the most detail to the least.
For example :debug would include :info, :warn, :error, :fatal levels but not :trace
And :fatal would only log :fatal error messages and nothing else</p>

<p>:unknown has been mapped to :fatal for Rails and Ruby Logger</p>

<p>:trace is a new level that is often used for tracing low level calls such
as the data sent or received to external web services. It is also commonly used
in the development environment for low level trace logging of methods calls etc.</p>

<p>If only the rails logger is being used, then :trace level calls will be logged
as debug calls only if the log level is set to trace</p>

<h3>
<a name="changing-the-class-name-for-log-entries" class="anchor" href="#changing-the-class-name-for-log-entries"><span class="octicon octicon-link"></span></a>Changing the Class name for Log Entries</h3>

<p>When Semantic Logger is included in a Rails project it automatically replaces the
loggers for Rails, ActiveRecord::Base, ActionController::Base, and ActiveResource::Base
with wrappers that set their Class name. For example in semantic_logger/railtie.rb:</p>

<div class="highlight highlight-ruby"><pre><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="no">ActiveRecord</span><span class="o">]</span>
</pre></div>

<p>By replacing their loggers we now get the class name in the text logging output:</p>

<pre><code>2012-08-30 15:24:13.439 D [47900:main] ActiveRecord --   SQL (12.0ms)  SELECT `schema_migrations`.`version` FROM `schema_migrations`
</code></pre>

<p>It is recommended to include a class specific logger for all major classes that will
be logging using the SemanticLogger::Loggable mix-in. For Example:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">ExternalSupplier</span>
  <span class="c1"># Lazy load logger class variable on first use</span>
  <span class="kp">include</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Loggable</span>

  <span class="k">def</span> <span class="nf">call_supplier</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="s2">"Calculating with amount"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:amount</span> <span class="o">=&gt;</span> <span class="n">amount</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="nb">name</span> <span class="p">}</span>

    <span class="c1"># Measure and log on completion how long the call took to the external supplier</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span> <span class="k">do</span>
      <span class="c1"># Code to call the external supplier ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>This will result in the log output identifying the log entry as from the ExternalSupplier class</p>

<pre><code>2012-08-30 15:37:29.474 I [48308:ScriptThreadProcess: script/rails] (5.2ms) ExternalSupplier -- Calling external interface
</code></pre>

<h3>
<a name="changing-the-log-level-for-a-single-class-at-runtime" class="anchor" href="#changing-the-log-level-for-a-single-class-at-runtime"><span class="octicon octicon-link"></span></a>Changing the log level for a single class at runtime</h3>

<p>Since the logger is class specific, its log level can be changed dynamically at runtime.
For example, to temporarily set the log level to :trace to diagnose an issue:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:info</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'example.log'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ExternalSupplier</span>
  <span class="c1"># Lazy load logger class variable on first use</span>
  <span class="kp">include</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Loggable</span>

  <span class="k">def</span> <span class="nf">call_supplier</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"Calculating with amount"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:amount</span> <span class="o">=&gt;</span> <span class="n">amount</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="nb">name</span> <span class="p">}</span>

    <span class="c1"># Measure and log on completion how long the call took to the external supplier</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span> <span class="k">do</span>
      <span class="c1"># Code to call the external supplier ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Create and use the class</span>
<span class="n">supplier</span> <span class="o">=</span> <span class="no">ExternalSupplier</span><span class="o">.</span><span class="n">new</span>
<span class="n">supplier</span><span class="o">.</span><span class="n">call_supplier</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">'Jack'</span><span class="p">)</span>

<span class="c1"># Now change the log level to :trace</span>
<span class="no">ExternalSupplier</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="ss">:trace</span>

<span class="c1"># Call the supplier, this time including trace level messages</span>
<span class="n">supplier</span><span class="o">.</span><span class="n">call_supplier</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">'Jack'</span><span class="p">)</span>

<span class="c1"># Change the log level back to the default level</span>
<span class="no">ExternalSupplier</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span>
</pre></div>

<p>Below is the output from the above example showing the :trace log level message
that was written during the second call to the ExternalSupplier:</p>

<pre><code>2013-11-07 16:19:26.496 I [35674:main] (0.0ms) ExternalSupplier -- Calling external interface

2013-11-07 16:19:26.683 T [35674:main] ExternalSupplier -- Calculating with amount -- {:amount=&gt;100, :name=&gt;"Jack"}
2013-11-07 16:19:26.683 I [35674:main] (0.0ms) ExternalSupplier -- Calling external interface
</code></pre>

<h3>
<a name="change-the-global-default-logging-level-at-runtime" class="anchor" href="#change-the-global-default-logging-level-at-runtime"><span class="octicon octicon-link"></span></a>Change the global default logging level at runtime</h3>

<p>Log levels can be changed using signals on operating systems that support them.
This allows log levels to be changed externally without requiring a restart
of the running process.</p>

<p>When the signal is raised, the global default log level rotates through the following
log levels in the following order, starting from the current global default level:</p>

<div class="highlight highlight-ruby"><pre>  <span class="ss">:warn</span><span class="p">,</span> <span class="ss">:info</span><span class="p">,</span> <span class="ss">:debug</span><span class="p">,</span> <span class="ss">:trace</span>
</pre></div>

<p>If the current level is :trace it wraps around back to :warn</p>

<p>Example:</p>

<pre><code>kill -SIGUSR2 1234
</code></pre>

<h4>
<a name="enabling-log-level-signal-handler" class="anchor" href="#enabling-log-level-signal-handler"><span class="octicon octicon-link"></span></a>Enabling Log Level Signal handler</h4>

<p>On startup SemanticLogger does not register any signals so that it does not
interfere with any existing signal handlers. In order to enable the above log level
changes the signal handler must be registered by calling <code>SemanticLogger.add_signal_handler</code></p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="c1"># Enable signal handling for this process</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="s1">'USR2'</span><span class="p">)</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
</pre></div>

<p>Note: The changes to the logging level will not change for any classes where the
log_level was set explicity within the application itself. The above signal only changes
the global default level, which is used by loggers when their log level has not been changed.</p>

<h4>
<a name="change-the-log-level-without-using-signals" class="anchor" href="#change-the-log-level-without-using-signals"><span class="octicon octicon-link"></span></a>Change the log level without using signals</h4>

<p>If the application has another means of communicating without needing signals,
the global default log level can be modified using <code>SemanticLogger.default_level=</code></p>

<div class="highlight highlight-ruby"><pre><span class="c1"># Change the global default logging level for active loggers</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:debug</span>
</pre></div>

<h3>
<a name="tagged-logging" class="anchor" href="#tagged-logging"><span class="octicon octicon-link"></span></a>Tagged Logging</h3>

<p>Semantic Logger allows any Ruby or Rails program to also include tagged logging.</p>

<p>This means that any logging performed within a block, including any called
libraries or gems to include the specified tag with every log entry.</p>

<p>Using Tagged logging is critical in any highly concurrent environment so that
one can quickly find all related log entries across all levels of code, and even
across threads</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">tagged</span><span class="p">(</span><span class="n">tracking_number</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="beyond-tagged-logging" class="anchor" href="#beyond-tagged-logging"><span class="octicon octicon-link"></span></a>Beyond Tagged Logging</h3>

<p>Blocks of code can be tagged with not only values, but can be tagged with
entire hashes of data. The additional hash of data will be merged into
the payload of every log entry</p>

<p>For example every corresponding log entry could include a hash containing
a user_id, name, region, zip_code, tracking_number, etc...</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">with_payload</span><span class="p">(</span><span class="ss">:user</span> <span class="o">=&gt;</span> <span class="s1">'Jack'</span><span class="p">,</span> <span class="ss">:zip_code</span> <span class="o">=&gt;</span> <span class="mi">12345</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="named-threads" class="anchor" href="#named-threads"><span class="octicon octicon-link"></span></a>Named threads</h3>

<p>SemanticLogger logs the name or id of the thread in every log message.</p>

<p>On Ruby MRI the thread name is by default the thread's object_id, For example: 70184354571980</p>

<pre><code>2013-11-07 16:25:14.279627 I [35841:70184354571980] (0.0ms) ExternalSupplier -- Calling external interface
</code></pre>

<p>To set a custom name for any thread so that it shows up in the logger:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"User calculation thread 32"</span>
</pre></div>

<p>Sample output:</p>

<pre><code>2013-11-07 16:26:02.744139 I [35841:User calculation thread 32] (0.0ms) ExternalSupplier -- Calling external interface
</code></pre>

<p>When running JRuby, Thread.current.name will also set the underlying thread name in the JVM
which is very useful when monitoring the JVM via JMX using tools such as jconsole.</p>

<h4>
<a name="note" class="anchor" href="#note"><span class="octicon octicon-link"></span></a>NOTE:</h4>

<p>Make sure that the assigned thread name is unique otherwise it will be difficult
to distinguish between concurrently running threads if they have the same name.</p>

<p>For example, use the current thread object_id to ensure uniqueness:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"Worker Thread:</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">object_id</span><span class="si">}</span><span class="s2">"</span>
</pre></div>

<h3>
<a name="metrics-integration" class="anchor" href="#metrics-integration"><span class="octicon octicon-link"></span></a>Metrics integration</h3>

<p>In production environments it is often necessary to not only measure the performance of a
block of code using for example:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span> <span class="k">do</span>
  <span class="c1"># Code to call the external supplier ...</span>
<span class="k">end</span>
</pre></div>

<p>A single subscriber can be defined to collect all the metrics and forward them
for example to NewRelic:</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># config/initializers/semantic_logger_metrics.rb</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">on_metric</span> <span class="k">do</span> <span class="o">|</span><span class="n">log_struct</span><span class="o">|</span>
  <span class="o">::</span><span class="no">NewRelic</span><span class="o">::</span><span class="no">Agent</span><span class="o">.</span><span class="n">record_metric</span><span class="p">(</span><span class="n">log_struct</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">log_struct</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>Add the :metric option to the log entry as follows:</p>

<div class="highlight highlight-ruby"><pre><span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span><span class="p">,</span> <span class="ss">:metric</span> <span class="o">=&gt;</span> <span class="s1">'Custom/slow_action/beginning_work'</span> <span class="k">do</span>
  <span class="c1"># Code to call the external supplier ...</span>
<span class="k">end</span>
</pre></div>

<h2>
<a name="standalone-semanticlogger" class="anchor" href="#standalone-semanticlogger"><span class="octicon octicon-link"></span></a>Standalone SemanticLogger</h2>

<p>When using SemanticLogger inside of Rails all we need to do is include the
rails_semantic_logger gem and the default Rails logger will be replaced with
Semantic Logger.</p>

<p>In a stand-alone or non-rails environment we can easily log to a file called
'development.log' as follows:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
</pre></div>

<p>By default it will only log :info and above, to log everything to the log file:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"Low level trace information"</span>
</pre></div>

<p>By supplying multiple appenders Semantic Logger can write to multiple destinations
at the same time. For example, log to a file and the screen:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"Low level trace information"</span>
</pre></div>

<p>To reduce the log level of logging to STDOUT to just :info and above, add the
log_level such as :info as the second parameter when adding the appender:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">,</span> <span class="ss">:info</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"Low level trace information"</span>
</pre></div>

<p>To log :debug and above to a log file, :error and above to $stderr, and :info
and above to MongoDB:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="nb">require</span> <span class="s1">'mongo'</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:debug</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="vg">$stderr</span><span class="p">,</span> <span class="ss">:error</span><span class="p">)</span>

<span class="n">mongo_appender</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">MongoDB</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
  <span class="ss">:db</span>              <span class="o">=&gt;</span> <span class="no">Mongodb</span><span class="o">::</span><span class="no">Connection</span><span class="o">.</span><span class="n">new</span><span class="o">[</span><span class="s1">'production_logging'</span><span class="o">]</span><span class="p">,</span>
  <span class="ss">:collection_size</span> <span class="o">=&gt;</span> <span class="mi">25</span><span class="o">.</span><span class="n">gigabytes</span>
<span class="p">)</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="n">mongo_appender</span><span class="p">,</span> <span class="ss">:info</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"Low level trace information"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">error</span> <span class="s2">"Oops an error occurred"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Login time"</span><span class="p">,</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="s1">'Mary'</span><span class="p">,</span> <span class="ss">:duration</span> <span class="o">=&gt;</span> <span class="mi">230</span><span class="p">,</span> <span class="ss">:ip_address</span><span class="o">=&gt;</span><span class="s1">'192.168.0.1'</span><span class="p">)</span>
</pre></div>

<p>When starting out with Semantic Logger it can be useful to gain all the benefits
of Semantic Logger and still continue to log to an existing logger:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'logger'</span>
<span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="c1"># Built-in Ruby logger</span>
<span class="n">log</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">::</span><span class="no">DEBUG</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:debug</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Example'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Login time"</span><span class="p">,</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="s1">'Joe'</span><span class="p">,</span> <span class="ss">:duration</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="p">,</span> <span class="ss">:ip_address</span><span class="o">=&gt;</span><span class="s1">'127.0.0.1'</span><span class="p">)</span>
</pre></div>

<p>It is recommended that every class or module have it's own logging instance.
This can be achieved by including SemanticLogger::Loggable:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ExternalSupplier</span>
  <span class="c1"># Makes available a class and instance level logger</span>
  <span class="c1">#    ExternalSupplier.logger and ExternalSupplier#logger</span>
  <span class="kp">include</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Loggable</span>

  <span class="c1"># logger class method example</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">hostname</span><span class="o">=</span><span class="p">(</span><span class="n">hostname</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="s2">"Setting hostname to </span><span class="si">#{</span><span class="n">hostname</span><span class="si">}</span><span class="s2">"</span>
    <span class="vc">@@hostname</span> <span class="o">=</span> <span class="n">hostname</span>
  <span class="k">end</span>

  <span class="c1"># logger instance method example</span>
  <span class="k">def</span> <span class="nf">call_supplier</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span> <span class="s2">"Calculating with amount"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:amount</span> <span class="o">=&gt;</span> <span class="n">amount</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="nb">name</span> <span class="p">}</span>

    <span class="c1"># Measure and log on completion how long the call took to the external supplier</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">benchmark_info</span> <span class="s2">"Calling external interface"</span> <span class="k">do</span>
      <span class="c1"># Code to call the external supplier ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="logging-to-syslog" class="anchor" href="#logging-to-syslog"><span class="octicon octicon-link"></span></a>Logging to Syslog</h3>

<p>Log to a local Syslog:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">Syslog</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
</pre></div>

<p>Log to a local file and to a remote Syslog server such as syslog-ng over TCP:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">Syslog</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:server</span> <span class="o">=&gt;</span> <span class="s1">'tcp://myloghost:514'</span><span class="p">))</span>
</pre></div>

<h2>
<a name="configuration" class="anchor" href="#configuration"><span class="octicon octicon-link"></span></a>Configuration</h2>

<p>The Semantic Logger follows the principle where multiple appenders can be active
at the same time. For example, this allows one to log to MongoDB and the Rails
log file at the same time.</p>

<h3>
<a name="rails-configuration" class="anchor" href="#rails-configuration"><span class="octicon octicon-link"></span></a>Rails Configuration</h3>

<p>To automatically replace the Rails logger with Semantic Logger use the gem <a href="http://github.com/reidmorrison/rails_semantic_logger">rails_semantic_logger</a></p>

<h2>
<a name="log-struct" class="anchor" href="#log-struct"><span class="octicon octicon-link"></span></a>Log Struct</h2>

<p>Internally all log messages are passed around in a Log Struct. In order
to write your own custom formatter or log appender it is necessary to understand
the fields:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Log</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:level</span><span class="p">,</span> <span class="ss">:thread_name</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:message</span><span class="p">,</span> <span class="ss">:payload</span><span class="p">,</span> <span class="ss">:time</span><span class="p">,</span> <span class="ss">:duration</span><span class="p">,</span> <span class="ss">:tags</span><span class="p">,</span> <span class="ss">:level_index</span><span class="p">,</span> <span class="ss">:exception</span><span class="p">,</span> <span class="ss">:metric</span><span class="p">)</span>
</pre></div>

<p>level [Symbol]</p>

<ul>
<li>Log level of the supplied log call</li>
<li>:trace, :debug, :info, :warn, :error, :fatal</li>
</ul><p>thread_name [String]</p>

<ul>
<li>Name or id of the thread in which the logging call was called</li>
</ul><p>name [String]</p>

<ul>
<li>Class name supplied to the logging instance</li>
</ul><p>message [String]</p>

<ul>
<li>Text message to be logged</li>
</ul><p>payload [Hash|Exception]</p>

<ul>
<li>Optional Hash or Ruby Exception object to be logged</li>
</ul><p>time [Time]</p>

<ul>
<li>The time at which the log entry was created</li>
</ul><p>duration [Float]</p>

<ul>
<li>The time taken in milli-seconds to complete a benchmark call</li>
</ul><p>tags [Array]</p>

<ul>
<li>Any tags active on the thread when the log call was made</li>
</ul><p>level_index [Integer]</p>

<ul>
<li>Internal use only. Index of the log level</li>
</ul><p>metric [Object]</p>

<ul>
<li>Object supplied when the benchmark api was called</li>
</ul><h3>
<a name="mixing-logging-levels" class="anchor" href="#mixing-logging-levels"><span class="octicon octicon-link"></span></a>Mixing Logging Levels</h3>

<p>It is sometimes useful to log a subset of the log messages to a separate file
or appender. For example, log :error and :fatal level messages to a special
error file.</p>

<p>Below is a stand-alone example that better shows this behavior:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="c1"># Set default log level for new logger instances</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:info</span>

<span class="c1"># Log all warning messages and above to warnings.log</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'log/warnings.log'</span><span class="p">,</span> <span class="ss">:warn</span><span class="p">)</span>

<span class="c1"># Log all trace messages and above to trace.log</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'log/trace.log'</span><span class="p">,</span> <span class="ss">:trace</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'MyClass'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="n">logger</span><span class="o">.</span><span class="n">trace</span> <span class="s2">"This is a trace message"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"This is an info message"</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warn</span> <span class="s2">"This is a warning message"</span>
</pre></div>

<p>The output is as follows:</p>

<div class="highlight highlight-bash"><pre><span class="o">==</span>&gt; trace.log &lt;<span class="o">==</span>
2013-08-02 14:15:56.733532 T <span class="o">[</span>35669:70176909690580<span class="o">]</span> MyClass -- This is a trace message
2013-08-02 14:15:56.734273 I <span class="o">[</span>35669:70176909690580<span class="o">]</span> MyClass -- This is an info message
2013-08-02 14:15:56.735273 W <span class="o">[</span>35669:70176909690580<span class="o">]</span> MyClass -- This is a warning <span class="nv">message</span>

<span class="o">==</span>&gt; warnings.log &lt;<span class="o">==</span>
2013-08-02 14:15:56.735273 W <span class="o">[</span>35669:70176909690580<span class="o">]</span> MyClass -- This is a warning message
</pre></div>

<h3>
<a name="custom-formatters" class="anchor" href="#custom-formatters"><span class="octicon octicon-link"></span></a>Custom Formatters</h3>

<p>The formatting for each appender can be replaced with custom code. To replace the
existing formatter supply a block of code when creating the appender.</p>

<p>Example: Formatter that just returns the Log Struct</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">log</span><span class="o">|</span>
 <span class="c1"># This formatter just returns the log struct as a string</span>
  <span class="n">log</span><span class="o">.</span><span class="n">inspect</span>
<span class="k">end</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Hello'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
</pre></div>

<p>Output:</p>

<pre><code>#&lt;struct SemanticLogger::Base::Log level=:info, thread_name=70167090649820, name="Hello", message="Hello World", payload=nil, time=2012-10-24 10:09:33 -0400, duration=nil, tags=nil, level_index=2&gt;
</code></pre>

<p>Example: Replace the default log file formatter</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>

<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'development.log'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">log</span><span class="o">|</span>
  <span class="n">tags</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">collect</span> <span class="p">{</span> <span class="o">|</span><span class="n">tag</span><span class="o">|</span> <span class="s2">"[</span><span class="si">#{</span><span class="n">tag</span><span class="si">}</span><span class="s2">]"</span> <span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" "</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">tags</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

  <span class="n">message</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">to_s</span>
  <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="s2">" -- "</span> <span class="o">&lt;&lt;</span> <span class="n">log</span><span class="o">.</span><span class="n">payload</span><span class="o">.</span><span class="n">inspect</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">payload</span>
  <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="s2">" -- "</span> <span class="o">&lt;&lt;</span> <span class="s2">"</span><span class="si">#{</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="se">\n</span><span class="si">#{</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">backtrace</span> <span class="o">||</span> <span class="o">[]</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">exception</span>

  <span class="n">duration_str</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">duration</span> <span class="p">?</span> <span class="s2">"(</span><span class="si">#{</span><span class="s1">'%.1f'</span> <span class="o">%</span> <span class="n">log</span><span class="o">.</span><span class="n">duration</span><span class="si">}</span><span class="s2">ms) "</span> <span class="p">:</span> <span class="s1">''</span>

  <span class="s2">"</span><span class="si">#{</span><span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">formatted_time</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">time</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">log</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">to_s</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">0</span><span class="o">].</span><span class="n">upcase</span><span class="si">}</span><span class="s2"> [</span><span class="si">#{</span><span class="vg">$$</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">log</span><span class="o">.</span><span class="n">thread_name</span><span class="si">}</span><span class="s2">] </span><span class="si">#{</span><span class="n">tags</span><span class="si">}#{</span><span class="n">duration_str</span><span class="si">}#{</span><span class="n">log</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> -- </span><span class="si">#{</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre></div>

<p>Example: Replace the default MongoDB formatter</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># Log to MongoDB and supply a custom document formatter</span>
<span class="n">mongodb_appender</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">MongoDB</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
  <span class="ss">:db</span>              <span class="o">=&gt;</span> <span class="no">Cache</span><span class="o">::</span><span class="no">Work</span><span class="o">.</span><span class="n">db</span><span class="p">,</span>
  <span class="ss">:collection_size</span> <span class="o">=&gt;</span> <span class="mi">25</span><span class="o">.</span><span class="n">gigabytes</span>
<span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">log</span><span class="o">|</span>
    <span class="c1"># Return a document (Hash) of the data to be saved to MongoDB</span>
    <span class="n">document</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">:time</span>        <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
      <span class="ss">:host_name</span>   <span class="o">=&gt;</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">MongoDB</span><span class="o">.</span><span class="n">host_name</span><span class="p">,</span>
      <span class="ss">:pid</span>         <span class="o">=&gt;</span> <span class="vg">$PID</span><span class="p">,</span>
      <span class="ss">:thread_name</span> <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">thread_name</span><span class="p">,</span>
      <span class="ss">:name</span>        <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
      <span class="ss">:level</span>       <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">level</span><span class="p">,</span>
      <span class="ss">:level_index</span> <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">level_index</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:application</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'MyApplication'</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:message</span><span class="o">]</span>     <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">MongoDB</span><span class="o">.</span><span class="n">strip_colorizing</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">message</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:duration</span><span class="o">]</span>    <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">duration</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">duration</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:tags</span><span class="o">]</span>        <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">tags</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">tags</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:payload</span><span class="o">]</span>     <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">payload</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">payload</span>
    <span class="n">document</span><span class="o">[</span><span class="ss">:exception</span><span class="o">]</span>   <span class="o">=</span> <span class="p">{</span>
      <span class="ss">:name</span>        <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
      <span class="ss">:message</span>     <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
      <span class="ss">:stack_trace</span> <span class="o">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">backtrace</span>
    <span class="p">}</span> <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">exception</span>
    <span class="n">document</span>
<span class="k">end</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="n">mongodb_appender</span><span class="p">)</span>
</pre></div>

<h2>
<a name="performance" class="anchor" href="#performance"><span class="octicon octicon-link"></span></a>Performance</h2>

<p>The traditional logging implementations write their log information to file in the
same thread of execution as the program itself. This means that for every log entry
the program has to wait for the data to be written.</p>

<p>With Semantic Logger it uses a dedicated thread for logging so that writing to
the log file or other appenders does not hold up program execution.</p>

<p>Also, since the logging is in this separate thread there is no impact to program
execution if we decided to add another appender.
For example, log to both a file and a MongoDB collection.</p>

<h2>
<a name="log-rotation" class="anchor" href="#log-rotation"><span class="octicon octicon-link"></span></a>Log Rotation</h2>

<p>Since the log file is not re-opened with every call, when the log file needs
to be rotated, use a copy-truncate operation over deleting the file.</p>

<h2>
<a name="why-semantic-logging" class="anchor" href="#why-semantic-logging"><span class="octicon octicon-link"></span></a>Why Semantic logging?</h2>

<p>Just as there is the initiative to add Semantic information to data on the web
so that computers can directly understand the content without having to resort
to complex regular expressions or machine learning techniques, it is important
to be able to do the same with log files or data.</p>

<p>Semantic Logger allows every log entry to have not only a message, but a payload
that can be written to a file or a NOSQL destination.</p>

<p>Once the logging data is in the NOSQL data store it can be queried quickly and
efficiently. Some SQL data stores also allow complex data types that could be used
for storing and querying the logging data</p>

<p>Before writing SemanticLogger all of the following logging frameworks were thoroughly
evaluated. None of them met the above Semantic requirements, or the performance requirements
of hundreds of threads all logging at the same time:
logback, logging, log4r, central_logger, whoops</p>

<h2>
<a name="architecture--performance" class="anchor" href="#architecture--performance"><span class="octicon octicon-link"></span></a>Architecture &amp; Performance</h2>

<p>In order to ensure that logging does not hinder the performance of the application
all log entries are written to thread-safe Queue. A separate thread is responsible
for writing the log entries to each of the appenders.</p>

<p>In this way formatting and disk or network write delays will not affect the
performance of the application. Also adding more than one appender does not affect
the runtime performance of the application.</p>

<p>The logging thread is automatically started on initialization. When the program
terminates it will call flush on each of the appenders.</p>

<p>Calling SemanticLogger::Logger#flush will wait until all outstanding log messages
have been written and flushed to their respective appenders before returning.</p>

<h2>
<a name="write-your-own-appender" class="anchor" href="#write-your-own-appender"><span class="octicon octicon-link"></span></a>Write your own Appender</h2>

<p>To write your own appender it should meet the following requirements:</p>

<ul>
<li>Inherit from SemanticLogger::Base</li>
<li>In the initializer connect to the resource being logged to</li>
<li>Implement #log(log) which needs to write to the relevant resource</li>
<li>Implement #flush if the resource can be flushed</li>
<li>Write a test for the new appender</li>
</ul><p>The #log method takes the log struct as a parameter which is described above.</p>

<p>Basic outline for an Appender:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'semantic_logger'</span>

<span class="k">class</span> <span class="nc">SimpleAppender</span> <span class="o">&lt;</span> <span class="no">SemanticLogger</span><span class="o">::</span><span class="no">Appender</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="c1"># Set the log level and formatter if supplied</span>
    <span class="k">super</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Display the log struct and the text formatted output</span>
  <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
    <span class="nb">p</span> <span class="n">log</span>
    <span class="nb">puts</span> <span class="n">formatter</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Optional</span>
  <span class="k">def</span> <span class="nf">flush</span>
    <span class="nb">puts</span> <span class="s2">"Flush :)"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Sample program calling the above appender:</p>

<div class="highlight highlight-ruby"><pre><span class="no">SemanticLogger</span><span class="o">.</span><span class="n">default_level</span> <span class="o">=</span> <span class="ss">:trace</span>
<span class="c1"># Log to file dev.log</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="s1">'dev.log'</span><span class="p">)</span>
<span class="c1"># Also log the above sample appender</span>
<span class="no">SemanticLogger</span><span class="o">.</span><span class="n">add_appender</span><span class="p">(</span><span class="no">SimpleAppender</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">SemanticLogger</span><span class="o">[</span><span class="s1">'Hello'</span><span class="o">]</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"Hello World"</span>
</pre></div>

<p>Look at the <a href="https://github.com/reidmorrison/semantic_logger/tree/master/lib/semantic_logger/appender">existing appenders</a> for good examples</p>

<p>To have your appender included in the standard list of appenders, submit it along
with complete working tests.
See the <a href="https://github.com/reidmorrison/semantic_logger/blob/master/test/appender_mongodb_test.rb">MongoDB Appender Test</a> for an example.</p>

<h2>
<a name="dependencies" class="anchor" href="#dependencies"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>See <a href="https://github.com/reidmorrison/semantic_logger/.travis.yml">.travis.yml</a> for the list of tested Ruby platforms</p>

<p>The following gems are only required when their corresponding appenders are being used,
and are therefore not automatically included by this gem:</p>

<ul>
<li>MongoDB Appender: mongo 1.9.2 or above</li>
<li>Syslog Appender: syslog_protocol 0.9.2 or above</li>
<li>Syslog Appender to a remote syslogng server over TCP or UDP: resilient_socket 0.5.0 or above</li>
</ul><h2>
<a name="install" class="anchor" href="#install"><span class="octicon octicon-link"></span></a>Install</h2>

<pre><code>gem install semantic_logger
</code></pre>

<h2>
<a name="upgrade-notes" class="anchor" href="#upgrade-notes"><span class="octicon octicon-link"></span></a>Upgrade Notes:</h2>

<p>As of SemanticLogger V2.0 the Rails logging is no longer automatically replaced
when including SemanticLogger. Include the <a href="http://github.com/reidmorrison/rails_semantic_logger">rails_semantic_logger</a>
gem to replace the Rails default logger with SemanticLogger</p>

<h2>
<a name="meta" class="anchor" href="#meta"><span class="octicon octicon-link"></span></a>Meta</h2>

<ul>
<li>Code: <code>git clone git://github.com/reidmorrison/semantic_logger.git</code>
</li>
<li>Home: <a href="https://github.com/reidmorrison/semantic_logger">https://github.com/reidmorrison/semantic_logger</a>
</li>
<li>Bugs: <a href="http://github.com/reidmorrison/semantic_logger/issues">http://github.com/reidmorrison/semantic_logger/issues</a>
</li>
<li>Gems: <a href="http://rubygems.org/gems/semantic_logger">http://rubygems.org/gems/semantic_logger</a>
</li>
</ul><p>This project uses <a href="http://semver.org/">Semantic Versioning</a>.</p>

<h2>
<a name="author" class="anchor" href="#author"><span class="octicon octicon-link"></span></a>Author</h2>

<p>Reid Morrison :: <a href="mailto:reidmo@gmail.com">reidmo@gmail.com</a> :: <a href="https://github.com/reidmorrison" class="user-mention">@reidmorrison</a></p>

<h2>
<a name="contributors" class="anchor" href="#contributors"><span class="octicon octicon-link"></span></a>Contributors</h2>

<p>Marc Bellingrath :: <a href="mailto:marrrc.b@gmail.com">marrrc.b@gmail.com</a></p>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>Copyright 2012, 2013, 2014 Reid Morrison</p>

<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>

<pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre>

<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/reidmorrison/semantic_logger/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/reidmorrison/semantic_logger/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/reidmorrison/semantic_logger"></a> is maintained by <a href="https://github.com/reidmorrison">reidmorrison</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>